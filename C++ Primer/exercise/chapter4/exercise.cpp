#include <iostream>
#include <vector>

using namespace std; 

void _4_1();
void _4_2();

int main()
{
    // _4_1();
    _4_2();
}

void _4_1()
{
    /**
     * 表达式 5+10*20/2 的求值结果是多少
     * 
     * 5+10*20/2 = 5 + ((10 * 20) / 2) = 105;
    */
    cout << "5+10*20/2 = " << 5+10*20/2 << endl;
}

void _4_2()
{
    /**
     * 添加括号，但需保证添加括号前后表达式的值不变
    */

    vector<int> vec{0, 1, 2};
    // 1
    auto vb1 = *vec.begin();
    auto vb2 = *(vec.begin()); // 运算符号优先级从高到低: . () *
    
    // 2
    auto vb3 = *vec.begin() + 1;
    auto vb4 = (*(vec.begin())) + 1;   // 运算符号优先级从高到低: . () * +

    cout << vb1 << endl;    // 0
    cout << vb2 << endl;    // 0
    cout << vb3 << endl;    // 1
    cout << vb4 << endl;    // 1
}

void _4_3()
{
    /**
     * C++没有明确规定大多数二元运算符的求值顺序，给编译器留下了优化的余地。
     * 这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡。
     * 你认为这可以接受吗？请说出你的理由。
     * 
     * 我觉得考虑到现代计算机的性能，以及这个策略可能导致的难以发现的缺陷。
     * 这个策略至少在当下（2023年）并不再适用了。
     * 明确的规则可以更好的规避潜在问题，这在后续节约的潜在成本很可能远远高过其提升的代码生成效率。
    */
}










