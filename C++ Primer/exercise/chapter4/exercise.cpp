#include <iostream>
#include <vector>
#include <limits>

using namespace std; 

void _4_1();
void _4_2();
void _4_4();
void _4_5();
void _4_7();
void _4_9();
void _4_10();
void _4_12();

int main()
{
    // _4_1();
    // _4_2();
    // _4_4();
    // _4_5();
    // _4_7();
    // _4_9();
    // _4_10();
    _4_12();
}

void _4_1()
{
    /**
     * 表达式 5+10*20/2 的求值结果是多少
     * 
     * 5+10*20/2 = 5 + ((10 * 20) / 2) = 105;
    */
    cout << "5+10*20/2 = " << 5+10*20/2 << endl;
}

void _4_2()
{
    /**
     * 添加括号，但需保证添加括号前后表达式的值不变
    */

    vector<int> vec{0, 1, 2};
    // 1
    auto vb1 = *vec.begin();
    auto vb2 = *(vec.begin()); // 运算符号优先级从高到低: . () *
    
    // 2
    auto vb3 = *vec.begin() + 1;
    auto vb4 = (*(vec.begin())) + 1;   // 运算符号优先级从高到低: . () * +

    cout << vb1 << endl;    // 0
    cout << vb2 << endl;    // 0
    cout << vb3 << endl;    // 1
    cout << vb4 << endl;    // 1
}

void _4_3()
{
    /**
     * C++没有明确规定大多数二元运算符的求值顺序，给编译器留下了优化的余地。
     * 这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡。
     * 你认为这可以接受吗？请说出你的理由。
     * 
     * 我觉得考虑到现代计算机的性能，以及这个策略可能导致的难以发现的缺陷。
     * 这个策略至少在当下（2023年）并不再适用了。
     * 明确的规则可以更好的规避潜在问题，这在后续节约的潜在成本很可能远远高过其提升的代码生成效率。
    */
}

void _4_4()
{
    /**
     * 在下面的表达式中添加括号，说明求值得过程和最终的结果。
     * 编译并输出两种结果，验证之前的推断。
    */

    auto x = 12 / 3 * 4 + 5 * 15 + 24 % 4 / 2;
    //             (4  * 4) + 75       + (       0 / 2)
    // 16 + 75 + 0 = 91;
    auto y = ((12 / 3) * 4) + (5 * 15) + ((24 % 4) / 2); // left to right, y = 91

    cout << "12 / 3 * 4 + 5 * 15 + 24 % 4 / 2 = " << x << endl;
    cout << "((12 / 3) * 4) + (5 * 15) + ((24 % 4) / 2) = " << y << endl;
}

void _4_5()
{
    /**
     * 写出下列表达式的求值结果
    */

    // 1
    int a = -30 * 3 + 21 / 5; // == (-30 * 3) + (21 / 5) == -90 + 4 == -86;

    // 2 
    int b = -30 + 3 * 21 / 5; // == -30 + ((3 * 21) / 5) == -30 + (63 / 5) == -30 + 12 == -18;

    // 3
    int c = 30 / 3 * 21 % 5; // jus left to right, == 10 * 21 % 5 == 210 % 5 == 0;

    // 4
    int d = -30 / 3 * 21 % 4; // jus left to right, == -10 * 21 % 4 == -210 % 4 == -2;

    cout << a << endl;
    cout << b << endl;
    cout << c << endl;
    cout << d << endl;
}

void _4_6()
{
    /**
     * 写出一条表达式用于确定一个整数是奇数还是偶数
    */
    int x = 19;
    bool bIsEven = x % 2 == 0 ? true : false;
}

void _4_7()
{
    /**
     * 溢出是什么含义？
     * 写出三条讲导致溢出的表达式
     * 
     * 溢出是指变量类型定义的长度不足以保存被赋予的值，导致的位溢出。
    */
    signed int x = INT_MAX + 1;
    signed short y = 65536 + 1;
    unsigned int z = -1;

    cout << x << endl;
    cout << y << endl;
    cout << z << endl;
}

void _4_8()
{
    /**
     * 说明在逻辑与、逻辑或及相等性运算符中
     * 对象求值的顺序
     * 
     * 逻辑与：先求左侧值，为true则求右侧值。为false则返回false，否则均为真，返回true。
     * 逻辑或：先求左侧值，为true则返回true。为false则求右侧值，同为false则返回false，反之返回true。
     * 相等性：C++标准未定义。
    */
}

void _4_9()
{
    /**
     * 解释下面的if语句中的条件部分的判断过程
    */

    const char *cp = "Hello World";
    if (cp && *cp)
        cout << 1 << endl;
    else
        cout << 0 << endl;
    
    /**
     * 首先判断变量cp的值是否是空字符串， 然后判断变量cp的地址是否是空地址
    */
}

void _4_10()
{
    /**
     * 为 while 循环写一个条件，使其从标准输入中读取整数，遇到42时停止
    */
    int n = 0;
    while (n != 42)
    {
        cin >> n;
        cout << "n is " << n << endl;
    }
}

void _4_11()
{
    /**
     * 写一个表达式用于测试4个值a b c d的关系，
     * 确保a大于b，b大于c， c大于d
    */
    int a, b ,c, d;
    if (a > b && b > c && c > d) return;
}

void _4_12()
{
    /**
     * 假设i, j, k是三个整数
     * 说明表达式 i != j < k 的含义
     * 
     * < 优先于 !=，j < k 这里会得出一个boolean类型的值，
     * 而由于i的类型为整数，所以基本上这个表达式是在比较变量i的值是0还是1.
    */

    int i = 0, j = 11, k = 10;
    if (i != j < k)
        cout << "true" << endl;
    else
        cout << "false" << endl;
}








